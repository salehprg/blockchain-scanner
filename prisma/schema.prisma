// Prisma schema to mirror existing database tables (no migrations generated here).

generator client {
  provider = "prisma-client-js"
   output   = "../src/generated/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model BlockchainConfigs {
  id           String  @id @default(uuid()) @db.Uuid
  chainId      Int     @unique
  rpcUrlBase   String  @db.Text
  rpcUrlAlter  String? @db.Text

  @@map("BlockchainConfigs")
}

model BlockchainContracts {
  id               String    @id @default(uuid()) @db.Uuid
  contractAddress  String    @unique @db.VarChar(100)
  contractType     String    @db.VarChar(20)
  chainId          Int
  lastSyncBlock    String?   @db.Text
  lastSyncTime     DateTime? @db.Timestamptz

  @@map("BlockchainContracts")
}

model NFTOwners {
  id                  String    @id @default(uuid()) @db.Uuid
  contractId          String    @db.Uuid
  ownerAddress        String    @db.VarChar(100)
  nftContractAddress  String    @db.VarChar(100)
  nftItemId           String    @db.Text
  count               Int
  lastTransactionHash String?   @db.VarChar(100)
  lastSyncTime        DateTime? @db.Timestamptz

  @@index([contractId])
  @@index([ownerAddress, nftContractAddress, nftItemId])
  @@map("NFTOwners")
}

model ContractLogs {
  id                 String   @id @default(uuid()) @db.Uuid
  contractId         String   @db.Uuid
  chainId            Int
  nftContractAddress String   @db.VarChar(100)
  blockNumber        String   @db.Text
  transactionHash    String   @db.VarChar(100)
  logIndex           Int
  eventType          String   @db.VarChar(50)
  fromAddress        String?  @db.VarChar(100)
  toAddress          String?  @db.VarChar(100)
  operatorAddress    String?  @db.VarChar(100)
  tokenId            String?  @db.Text
  value              String?  @db.Text
  loggedAt           DateTime @db.Timestamptz

  @@unique([transactionHash, logIndex])
  @@index([contractId, blockNumber])
  @@map("ContractLogs")
}

model NFTs {
  id                   String       @id @default(uuid()) @db.Uuid
  contractId           String       @db.Uuid
  nftContractAddress   String       @db.VarChar(100)
  tokenId              String       @db.Text
  tokenUri             String?      @db.Text
  metadataUpdated      Boolean      @default(false)
  lastMetadataSyncTime DateTime?    @db.Timestamptz
  metadata             NFTMetadata?

  @@unique([nftContractAddress, tokenId])
  @@map("NFTs")
}

model NFTMetadata {
  id          String  @id @default(uuid()) @db.Uuid
  nftId       String  @unique @db.Uuid
  name        String? @db.Text
  description String? @db.Text
  image       String? @db.Text
  externalUrl String? @db.Text
  attributes  Json?
  raw         Json?
  nft         NFTs    @relation(fields: [nftId], references: [id], onDelete: Cascade)

  @@map("NFTMetadata")
}


